<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ç½‘é¡µæ¸¸æˆï¼šRoguelike Survivors</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 800px at 20% 20%, rgba(120,160,255,.12), transparent 60%),
                  radial-gradient(1200px 800px at 80% 80%, rgba(255,120,200,.10), transparent 60%),
                  #070a12;
      color:#e8ecff; font-family: system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      overflow:hidden;
    }
    .wrap{ width:min(95vw, 980px); }
    .hud{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .title{ font-weight:900; letter-spacing:.4px; }
    .pills{ display:flex; gap:10px; flex-wrap:wrap; font-size:14px; }
    .pill{
      padding:7px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(14px);
    }
    .panel{
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 18px 70px rgba(0,0,0,.40);
      backdrop-filter: blur(18px);
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      touch-action:none;
    }
    .row{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    button{
      appearance:none; border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color:#e8ecff; padding:10px 12px; border-radius:12px;
      font-weight:800; cursor:pointer;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    .hint{ margin-top:10px; font-size:13px; opacity:.82; line-height:1.55; }

    /* å‡çº§å¼¹çª— */
    .overlay{
      position: fixed; inset: 0; display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.55);
      padding: 16px;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(720px, 100%);
      border-radius: 20px;
      background: rgba(15,18,30,.88);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 30px 120px rgba(0,0,0,.60);
      padding: 16px;
      backdrop-filter: blur(18px);
    }
    .modal h2{ margin: 4px 0 12px; font-size:18px; }
    .choices{
      display:grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
    }
    .card{
      border-radius: 16px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      padding: 12px;
      cursor:pointer;
      min-height: 94px;
    }
    .card:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .card .name{ font-weight:900; margin-bottom:6px; }
    .card .desc{ font-size:13px; opacity:.85; line-height:1.35; }
    .footerNote{ margin-top: 10px; font-size: 12px; opacity:.75; }

    /* æ‰‹æœºæ‘‡æ† */
    .stick{
      position: fixed; left: 14px; bottom: 14px;
      width: 140px; height: 140px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(14px);
      display:none;
      touch-action:none;
      user-select:none;
    }
    .stick.show{ display:block; }
    .knob{
      position:absolute; left:50%; top:50%;
      width: 54px; height: 54px; margin-left:-27px; margin-top:-27px;
      border-radius: 999px;
      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="title">âš”ï¸ Roguelike Survivorsï¼ˆé«˜çº§å•æ–‡ä»¶ï¼‰</div>
      <div class="pills">
        <div class="pill">HPï¼š<span id="hp">0</span>/<span id="hpMax">0</span></div>
        <div class="pill">ç­‰çº§ï¼š<span id="lv">1</span></div>
        <div class="pill">EXPï¼š<span id="exp">0</span>/<span id="expNeed">0</span></div>
        <div class="pill">å‡»æ€ï¼š<span id="kills">0</span></div>
        <div class="pill">æ—¶é—´ï¼š<span id="time">0:00</span></div>
      </div>
    </div>

    <div class="panel">
      <canvas id="game" width="960" height="540"></canvas>
      <div class="row">
        <button id="btnRestart">é‡æ–°å¼€å§‹</button>
        <button id="btnPause">æš‚åœ</button>
      </div>
      <div class="hint">
        ç”µè„‘ï¼šWASD / æ–¹å‘é”®ç§»åŠ¨ï¼Œè‡ªåŠ¨å°„å‡»ï¼ŒP/ç©ºæ ¼æš‚åœã€‚<br/>
        æ‰‹æœºï¼šå·¦ä¸‹è§’æ‘‡æ†ç§»åŠ¨ï¼ˆè‹¥æœªæ˜¾ç¤ºï¼Œç‚¹ä¸€ä¸‹å±å¹•ï¼‰ã€‚<br/>
        å‡çº§ä¼šå¼¹å‡ºâ€œä¸‰é€‰ä¸€æŠ€èƒ½â€ï¼Œè¶Šæ´»è¶Šå¼ºã€‚
      </div>
    </div>
  </div>

  <div class="stick" id="stick" aria-label="æ‘‡æ†">
    <div class="knob" id="knob"></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h2>å‡çº§ï¼é€‰æ‹©ä¸€ä¸ªå¼ºåŒ–</h2>
      <div class="choices" id="choices"></div>
      <div class="footerNote">æç¤ºï¼šä¼˜å…ˆâ€œå°„é€Ÿ/ç©¿é€/ç§»é€Ÿâ€ä¼šæ›´çˆ½ã€‚</div>
    </div>
  </div>

<script>
(() => {
  // ====== åŸºç¡€å·¥å…· ======
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const len = (x,y) => Math.hypot(x,y);
  const norm = (x,y) => {
    const l = Math.hypot(x,y) || 1;
    return [x/l, y/l];
  };
  const rand = (a,b) => a + Math.random()*(b-a);
  const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];

  // ====== ç”»å¸ƒ ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // è§†é‡/ä¸–ç•Œ
  const W = canvas.width, H = canvas.height;
  const world = { w: 2600, h: 1800 };

  // ====== HUD ======
  const el = (id) => document.getElementById(id);
  const hpEl = el('hp'), hpMaxEl = el('hpMax');
  const lvEl = el('lv'), expEl = el('exp'), expNeedEl = el('expNeed');
  const killsEl = el('kills'), timeEl = el('time');

  // ====== UI ======
  const overlay = el('overlay');
  const choicesEl = el('choices');
  const btnRestart = el('btnRestart');
  const btnPause = el('btnPause');

  // æ‘‡æ†
  const stick = el('stick');
  const knob = el('knob');
  let joyActive = false, joyId = null;
  let joyCenter = {x:0,y:0};
  let joyVec = {x:0,y:0}; // -1..1

  // ====== è¾“å…¥ ======
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);
    if (k === ' ' || k === 'p') { e.preventDefault(); togglePause(); }
  }, {passive:false});
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  // ç‚¹å‡»/è§¦æ‘¸ï¼šæ˜¾ç¤ºæ‘‡æ†ï¼ˆç§»åŠ¨ç«¯ï¼‰
  const isTouch = matchMedia('(pointer: coarse)').matches;
  if (isTouch) stick.classList.add('show');
  window.addEventListener('pointerdown', () => { if (isTouch) stick.classList.add('show'); }, {once:true});

  // æ‘‡æ†äº‹ä»¶
  stick.addEventListener('pointerdown', (e) => {
    joyActive = true; joyId = e.pointerId;
    stick.setPointerCapture(joyId);
    const r = stick.getBoundingClientRect();
    joyCenter = {x: r.left + r.width/2, y: r.top + r.height/2};
    updateJoy(e.clientX, e.clientY);
  });
  stick.addEventListener('pointermove', (e) => {
    if (!joyActive || e.pointerId !== joyId) return;
    updateJoy(e.clientX, e.clientY);
  });
  stick.addEventListener('pointerup', (e) => {
    if (e.pointerId !== joyId) return;
    joyActive = false; joyId = null;
    joyVec.x = 0; joyVec.y = 0;
    knob.style.transform = `translate(0px,0px)`;
  });

  function updateJoy(px, py){
    const dx = px - joyCenter.x;
    const dy = py - joyCenter.y;
    const maxR = 42;
    const l = Math.hypot(dx,dy);
    const nx = (l > 0) ? dx / Math.max(l, 1) : 0;
    const ny = (l > 0) ? dy / Math.max(l, 1) : 0;
    const mag = clamp(l / maxR, 0, 1);
    joyVec.x = nx * mag;
    joyVec.y = ny * mag;
    knob.style.transform = `translate(${nx*mag*maxR}px, ${ny*mag*maxR}px)`;
  }

  // ====== æ¸¸æˆçŠ¶æ€ ======
  let running = true;
  let paused = false;
  let t0 = performance.now();

  const player = {
    x: world.w/2, y: world.h/2,
    r: 16,
    hpMax: 100, hp: 100,
    speed: 240, // px/s
    dmg: 14,
    fireRate: 3.2, // shots/s
    bulletSpeed: 520,
    pierce: 1, // ç©¿é€æ•°é‡
    invuln: 0
  };

  let bullets = [];
  let enemies = [];
  let orbs = [];   // ç»éªŒçƒ
  let kills = 0;

  let level = 1;
  let exp = 0;
  let expNeed = 40;

  // åˆ·æ€ª
  let spawnTimer = 0;
  let spawnRate = 0.85; // ç§’
  let diff = 1;

  // å°„å‡»
  let fireCd = 0;

  // ====== å‡çº§æ±  ======
  const upgrades = [
    {
      key:'firerate', name:'ğŸ”¥ å°„é€Ÿ +20%',
      desc:'æ›´é¢‘ç¹å°„å‡»ï¼ˆæå‡æ¸…åœºæ•ˆç‡ï¼‰',
      apply: () => player.fireRate *= 1.2
    },
    {
      key:'dmg', name:'ğŸ’¥ ä¼¤å®³ +25%',
      desc:'æ¯å‘å­å¼¹æ›´ç—›ï¼ˆæ›´å¿«ç§’æ€ªï¼‰',
      apply: () => player.dmg *= 1.25
    },
    {
      key:'speed', name:'ğŸ’¨ ç§»é€Ÿ +15%',
      desc:'æ›´å®¹æ˜“é£ç­ä¸èµ°ä½',
      apply: () => player.speed *= 1.15
    },
    {
      key:'pierce', name:'ğŸ—¡ï¸ ç©¿é€ +1',
      desc:'å­å¼¹å¯ç©¿æ›´å¤šæ•Œäºº',
      apply: () => player.pierce += 1
    },
    {
      key:'hp', name:'ğŸ©¸ æœ€å¤§ç”Ÿå‘½ +20',
      desc:'æ›´è€æ‰“ï¼ŒåŒæ—¶å›å¤åˆ°æ»¡è¡€',
      apply: () => { player.hpMax += 20; player.hp = player.hpMax; }
    },
    {
      key:'bullet', name:'ğŸ¯ å¼¹é€Ÿ +15%',
      desc:'æ›´å®¹æ˜“å‘½ä¸­å¿«é€Ÿæ•Œäºº',
      apply: () => player.bulletSpeed *= 1.15
    }
  ];

  // ====== æ§åˆ¶æŒ‰é’® ======
  btnRestart.addEventListener('click', () => reset());
  btnPause.addEventListener('click', () => togglePause());

  function togglePause(){
    if (!running) return;
    paused = !paused;
  }

  function reset(){
    running = true; paused = false;
    t0 = performance.now();
    player.x = world.w/2; player.y = world.h/2;
    player.hpMax = 100; player.hp = 100;
    player.speed = 240;
    player.dmg = 14;
    player.fireRate = 3.2;
    player.bulletSpeed = 520;
    player.pierce = 1;
    player.invuln = 0;

    bullets = [];
    enemies = [];
    orbs = [];
    kills = 0;

    level = 1; exp = 0; expNeed = 40;
    spawnTimer = 0; spawnRate = 0.85; diff = 1;
    fireCd = 0;

    overlay.classList.remove('show');
    updateHUD();
  }

  // ====== ç»éªŒ&å‡çº§ ======
  function gainExp(amount){
    exp += amount;
    while (exp >= expNeed) {
      exp -= expNeed;
      level += 1;
      expNeed = Math.floor(expNeed * 1.22 + 10);
      // éš¾åº¦éšç­‰çº§ä¸Šå‡
      diff = 1 + (level-1)*0.08;
      spawnRate = Math.max(0.25, 0.85 - (level-1)*0.02);
      // å¼¹å‡ºå‡çº§
      openUpgrade();
    }
  }

  function openUpgrade(){
    paused = true;
    overlay.classList.add('show');

    choicesEl.innerHTML = '';
    const pool = [...upgrades];
    // æŠ½3ä¸ªä¸é‡å¤
    const picks = [];
    while (picks.length < 3 && pool.length) {
      const u = pool.splice(Math.floor(Math.random()*pool.length), 1)[0];
      picks.push(u);
    }

    for (const u of picks){
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `<div class="name">${u.name}</div><div class="desc">${u.desc}</div>`;
      div.addEventListener('click', () => {
        u.apply();
        overlay.classList.remove('show');
        paused = false;
        updateHUD();
      });
      choicesEl.appendChild(div);
    }
  }

  // ====== å®ä½“åˆ›å»º ======
  function spawnEnemy(){
    // åœ¨å±å¹•å¤–è¾¹ç¼˜ç”Ÿæˆ
    const margin = 260;
    const cam = camera();
    const side = Math.floor(Math.random()*4);
    let x,y;
    if (side===0){ x = cam.x - margin; y = cam.y + rand(-margin, H+margin); }
    if (side===1){ x = cam.x + W + margin; y = cam.y + rand(-margin, H+margin); }
    if (side===2){ x = cam.x + rand(-margin, W+margin); y = cam.y - margin; }
    if (side===3){ x = cam.x + rand(-margin, W+margin); y = cam.y + H + margin; }

    // clamp åˆ°ä¸–ç•ŒèŒƒå›´å¤–ç¨è®¸ï¼ˆå…è®¸è¾¹ç¼˜åˆ·ï¼‰
    x = clamp(x, -80, world.w+80);
    y = clamp(y, -80, world.h+80);

    const base = 26;
    const r = clamp(base * rand(0.75, 1.15), 16, 34);
    const hp = Math.floor((22 + r*0.9) * diff);
    const speed = clamp((90 + rand(-20, 30)) * (1 + (diff-1)*0.25), 80, 220);

    enemies.push({ x,y,r, hp, hpMax: hp, speed, hitCd: 0 });
  }

  function fireAt(targetX, targetY){
    const dx = targetX - player.x;
    const dy = targetY - player.y;
    const [nx, ny] = norm(dx, dy);
    const sp = player.bulletSpeed;
    bullets.push({
      x: player.x + nx*(player.r+6),
      y: player.y + ny*(player.r+6),
      vx: nx*sp, vy: ny*sp,
      r: 5,
      dmg: player.dmg,
      pierce: player.pierce,
      life: 1.6
    });
  }

  function dropOrb(x,y){
    orbs.push({ x,y, r: 6, v: 0, t: 0 });
  }

  // ====== æ‘„åƒæœº ======
  function camera(){
    // è®©ç©å®¶å±…ä¸­ï¼Œä½†é™åˆ¶åœ¨ä¸–ç•Œè¾¹ç•Œ
    const cx = clamp(player.x - W/2, 0, world.w - W);
    const cy = clamp(player.y - H/2, 0, world.h - H);
    return { x: cx, y: cy };
  }

  // ====== æ›´æ–° ======
  function update(dt){
    if (!running || paused) return;

    // æ—¶é—´éš¾åº¦ï¼ˆå­˜æ´»è¶Šä¹…è¶Šéš¾ï¼‰
    const alive = (performance.now() - t0) / 1000;
    const timeFactor = 1 + alive * 0.015;
    const curDiff = diff * timeFactor;

    // ç©å®¶ç§»åŠ¨
    let mx = 0, my = 0;
    if (keys.has('w') || keys.has('arrowup')) my -= 1;
    if (keys.has('s') || keys.has('arrowdown')) my += 1;
    if (keys.has('a') || keys.has('arrowleft')) mx -= 1;
    if (keys.has('d') || keys.has('arrowright')) mx += 1;

    // æ‰‹æœºæ‘‡æ†å åŠ 
    if (isTouch) { mx += joyVec.x; my += joyVec.y; }

    if (mx !== 0 || my !== 0){
      const [nx, ny] = norm(mx, my);
      player.x = clamp(player.x + nx * player.speed * dt, 0, world.w);
      player.y = clamp(player.y + ny * player.speed * dt, 0, world.h);
    }

    if (player.invuln > 0) player.invuln -= dt;

    // åˆ·æ€ª
    spawnTimer += dt;
    const rate = Math.max(0.18, spawnRate / timeFactor);
    while (spawnTimer >= rate){
      spawnTimer -= rate;
      // æ¯æ¬¡å¯èƒ½åˆ·å¤šä¸ªï¼ˆéšæ—¶é—´ï¼‰
      const pack = (alive > 60) ? 2 : (alive > 120 ? 3 : 1);
      for (let i=0;i<pack;i++) spawnEnemy();
    }

    // è‡ªåŠ¨å°„å‡»ï¼šæ‰¾æœ€è¿‘æ•Œäºº
    fireCd -= dt;
    if (fireCd <= 0 && enemies.length){
      const e = nearestEnemy();
      if (e){
        fireAt(e.x, e.y);
        fireCd = 1 / player.fireRate;
      }
    }

    // å­å¼¹æ›´æ–°
    for (let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if (b.life <= 0 || b.x < -200 || b.y < -200 || b.x > world.w+200 || b.y > world.h+200){
        bullets.splice(i,1);
      }
    }

    // æ•Œäººæ›´æ–°&è¿½è¸ª
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      const dx = player.x - e.x, dy = player.y - e.y;
      const [nx, ny] = norm(dx, dy);
      e.x += nx * e.speed * dt;
      e.y += ny * e.speed * dt;

      if (e.hitCd > 0) e.hitCd -= dt;

      // æ•Œäººç¢°æ’ç©å®¶
      const d = Math.hypot(player.x - e.x, player.y - e.y);
      if (d < player.r + e.r){
        if (player.invuln <= 0){
          player.hp -= 10;
          player.invuln = 0.55;
          if (player.hp <= 0){
            player.hp = 0;
            running = false;
            paused = false;
          }
        }
      }
    }

    // å­å¼¹ vs æ•Œäººç¢°æ’
    for (let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      for (let ei=enemies.length-1; ei>=0; ei--){
        const e = enemies[ei];
        const d = Math.hypot(b.x - e.x, b.y - e.y);
        if (d < b.r + e.r){
          // å‘½ä¸­
          e.hp -= b.dmg;
          b.pierce -= 1;

          // è½»å¾®å‡»é€€/å—å‡»å†·å´ï¼ˆè§†è§‰ï¼‰
          e.hitCd = 0.08;

          if (e.hp <= 0){
            // æ­»äº¡
            kills += 1;
            dropOrb(e.x, e.y);
            enemies.splice(ei, 1);
          }

          if (b.pierce < 0){
            bullets.splice(bi, 1);
            break;
          }
        }
      }
    }

    // ç»éªŒçƒï¼šå¸é™„åˆ°ç©å®¶
    for (let i=orbs.length-1;i>=0;i--){
      const o = orbs[i];
      const dx = player.x - o.x, dy = player.y - o.y;
      const d = Math.hypot(dx, dy);

      // å¸é™„èŒƒå›´
      if (d < 220){
        const pull = (220 - d) / 220;
        const [nx, ny] = norm(dx, dy);
        o.x += nx * (120 + pull*360) * dt;
        o.y += ny * (120 + pull*360) * dt;
      }

      if (d < player.r + o.r + 6){
        gainExp(10);
        orbs.splice(i,1);
      }
    }

    updateHUD();
  }

  function nearestEnemy(){
    let best = null;
    let bestD = Infinity;
    for (const e of enemies){
      const d = (e.x - player.x)**2 + (e.y - player.y)**2;
      if (d < bestD){ bestD = d; best = e; }
    }
    return best;
  }

  function updateHUD(){
    hpEl.textContent = Math.ceil(player.hp);
    hpMaxEl.textContent = Math.ceil(player.hpMax);
    lvEl.textContent = level;
    expEl.textContent = Math.floor(exp);
    expNeedEl.textContent = expNeed;
    killsEl.textContent = kills;

    const s = Math.floor((performance.now() - t0)/1000);
    const mm = Math.floor(s/60);
    const ss = String(s%60).padStart(2,'0');
    timeEl.textContent = `${mm}:${ss}`;
  }

  // ====== ç»˜åˆ¶ ======
  function draw(){
    const cam = camera();
    ctx.clearRect(0,0,W,H);

    // èƒŒæ™¯ç½‘æ ¼
    ctx.globalAlpha = 0.18;
    ctx.lineWidth = 1;
    for (let x = -(cam.x%60); x < W; x += 60){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y = -(cam.y%60); y < H; y += 60){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // ä¸–ç•Œè¾¹ç•Œé˜´å½±
    ctx.globalAlpha = 0.22;
    ctx.fillRect(-cam.x, -cam.y, world.w, world.h);
    ctx.globalAlpha = 1;

    // ç»éªŒçƒ
    for (const o of orbs){
      const sx = o.x - cam.x, sy = o.y - cam.y;
      circle(sx, sy, o.r, "rgba(255,255,255,.85)");
    }

    // å­å¼¹
    for (const b of bullets){
      const sx = b.x - cam.x, sy = b.y - cam.y;
      circle(sx, sy, b.r, "rgba(255,255,255,.92)");
    }

    // æ•Œäºº + è¡€æ¡
    for (const e of enemies){
      const sx = e.x - cam.x, sy = e.y - cam.y;
      const a = (e.hitCd > 0) ? 1 : 0.85;
      circle(sx, sy, e.r, `rgba(255,255,255,${a})`);

      // è¡€æ¡
      const w = e.r*1.6, h = 5;
      const p = clamp(e.hp / e.hpMax, 0, 1);
      rect(sx-w/2, sy-e.r-12, w, h, "rgba(0,0,0,.35)");
      rect(sx-w/2, sy-e.r-12, w*p, h, "rgba(255,255,255,.7)");
    }

    // ç©å®¶ï¼ˆå¸¦æ— æ•Œé—ªçƒï¼‰
    const px = player.x - cam.x, py = player.y - cam.y;
    const blink = (player.invuln > 0) ? (Math.sin(performance.now()/55)*0.5+0.5) : 1;
    circle(px, py, player.r, `rgba(255,255,255,${0.85*blink})`);

    // ç©å®¶è¡€æ¡
    const barW = 220, barH = 10;
    const hpP = clamp(player.hp / player.hpMax, 0, 1);
    rect(14, 14, barW, barH, "rgba(0,0,0,.35)");
    rect(14, 14, barW*hpP, barH, "rgba(255,255,255,.75)");

    // Game Over
    if (!running){
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;

      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.font = "900 40px system-ui";
      const t = "æ¸¸æˆç»“æŸ";
      ctx.fillText(t, (W-ctx.measureText(t).width)/2, H*0.44);

      ctx.font = "700 18px system-ui";
      const t2 = `å‡»æ€ï¼š${kills}  ç­‰çº§ï¼š${level}  å­˜æ´»ï¼š${timeEl.textContent}`;
      ctx.fillText(t2, (W-ctx.measureText(t2).width)/2, H*0.52);

      ctx.font = "800 16px system-ui";
      const t3 = "ç‚¹å‡»â€œé‡æ–°å¼€å§‹â€å†æ¥ä¸€å±€";
      ctx.fillText(t3, (W-ctx.measureText(t3).width)/2, H*0.60);
    }

    // Paused
    if (running && paused && !overlay.classList.contains('show')){
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.font = "900 28px system-ui";
      const t = "å·²æš‚åœ";
      ctx.fillText(t, (W-ctx.measureText(t).width)/2, H*0.52);
    }
  }

  function circle(x,y,r,fill){
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();
  }
  function rect(x,y,w,h,fill){
    ctx.fillStyle = fill;
    ctx.fillRect(x,y,w,h);
  }

  // ====== ä¸»å¾ªç¯ ======
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // å¯åŠ¨
  reset();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
