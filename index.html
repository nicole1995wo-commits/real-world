<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>ZÁÇÆ ÊàêÂìÅËØïÁé©Ôºà6ÊÆµÊãºË£ÖÁâàÔºâ</title>
<style>
  :root{ color-scheme:dark; }
  body{ margin:0; overflow:hidden; background:#070a12; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:#e8ecff; }
  canvas{ width:100vw; height:100vh; display:block; touch-action:none; }
  .hud{ position:fixed; left:12px; right:12px; top:10px; z-index:20; display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; pointer-events:none;}
  .pill{ pointer-events:none; padding:10px 12px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(14px); font-weight:900; font-size:13px;}
  .right{ position:fixed; right:12px; top:72px; z-index:30; display:flex; flex-direction:column; gap:10px; }
  .btn{ pointer-events:auto; user-select:none; cursor:pointer; padding:12px 14px; border-radius:14px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14); font-weight:950; font-size:14px; box-shadow:0 14px 55px rgba(0,0,0,.35);}
  .btn:active{ transform: translateY(1px); }
  .stick{ position:fixed; bottom:16px; width:154px; height:154px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(14px); display:none; z-index:25; touch-action:none; }
  .stick.show{ display:block; }  #stickMove{ left:16px; }  #stickAim{ right:16px; }
  .knob{ position:absolute; left:50%; top:50%; width:58px; height:58px; margin-left:-29px; margin-top:-29px; border-radius:999px; background:rgba(255,255,255,.16); border:1px solid rgba(255,255,255,.22); box-shadow:0 10px 30px rgba(0,0,0,.35); pointer-events:none; }
  .overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.62); z-index:50; padding:16px;}
  .overlay.show{ display:flex; }
  .modal{ width:min(980px, 100%); border-radius:20px; background:rgba(14,18,30,.92); border:1px solid rgba(255,255,255,.14); box-shadow:0 30px 140px rgba(0,0,0,.65); padding:14px; backdrop-filter: blur(16px); }
  .modalTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; padding:6px 6px 10px; }
  .cards{ display:grid; grid-template-columns:repeat(3,1fr); gap:10px; }
  .card{ cursor:pointer; border-radius:16px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); padding:12px; min-height:108px; transition:transform .08s ease, background .08s ease; }
  .card:hover{ transform: translateY(-1px); background:rgba(255,255,255,.10); }
  .card .t{ font-weight:1000; margin-bottom:6px; } .card .d{ font-size:13px; opacity:.85; line-height:1.35; }
  .note{ font-size:12px; opacity:.75; padding:10px 6px 4px; line-height:1.4; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div class="pill">HP <span id="hp">-</span>/<span id="hpMax">-</span>ÔΩúÊä§Áõæ <span id="sh">-</span>ÔΩúÈáëÂ∏Å <span id="gold">0</span></div>
  <div class="pill">Ê≥¢Ê¨° <span id="wave">1</span>ÔΩúÂâ©‰Ωô <span id="left">0</span>ÔΩúÂáªÊùÄ <span id="kills">0</span></div>
  <div class="pill">DPS <span id="dps">-</span>ÔΩúÊ®°Âºè <span id="mode">ÊàòÊñó</span>ÔΩúFPS <span id="fps">-</span></div>
</div>

<div class="right">
  <div class="btn" id="btnSkill">ÊäÄËÉΩÔºàÁ©∫Ê†ºÔºâ</div>
  <div class="btn" id="btnShop">ÂïÜÂ∫óÔºàEÔºâ</div>
  <div class="btn" id="btnMeta">Â±ÄÂ§ñÂÖªÊàê</div>
  <div class="btn" id="btnPause">ÊöÇÂÅúÔºàPÔºâ</div>
</div>

<div class="stick" id="stickMove"><div class="knob" id="knobMove"></div></div>
<div class="stick" id="stickAim"><div class="knob" id="knobAim"></div></div>

<div class="overlay" id="overlay">
  <div class="modal">
    <div class="modalTop">
      <h3 id="modalTitle" style="margin:0">Èù¢Êùø</h3>
      <div class="btn" id="modalClose">ÂÖ≥Èó≠</div>
    </div>
    <div class="cards" id="cards"></div>
    <div class="note" id="modalNote"></div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  // ===== Global Game Object (later parts will extend this) =====
  const ZG = window.ZG = {
    v: "1.0",
    // canvas
    canvas: $("c"),
    ctx: null,
    w: innerWidth, h: innerHeight, dpr: 1,
    // ui
    ui: {
      hp:$("hp"), hpMax:$("hpMax"), sh:$("sh"), gold:$("gold"),
      wave:$("wave"), left:$("left"), kills:$("kills"), dps:$("dps"), mode:$("mode"), fps:$("fps"),
      btnSkill:$("btnSkill"), btnShop:$("btnShop"), btnMeta:$("btnMeta"), btnPause:$("btnPause"),
      overlay:$("overlay"), modalTitle:$("modalTitle"), modalClose:$("modalClose"), cards:$("cards"), modalNote:$("modalNote"),
    },
    // helpers
    clamp:(v,a,b)=>Math.max(a,Math.min(b,v)),
    rand:(a,b)=>a+Math.random()*(b-a),
    norm:(x,y)=>{ const l=Math.hypot(x,y)||1; return [x/l,y/l]; },
    lerp:(a,b,t)=>a+(b-a)*t,
    now:()=>performance.now(),
    // state
    paused:false,
    mode:"battle", // battle / meta
    shake:0,
    // world
    world:{ w:4200, h:2800 },
    cam:{ x:0, y:0 },
    // input
    keys:new Set(),
    mouse:{ x:innerWidth*0.5, y:innerHeight*0.5 },
    isTouch: matchMedia('(pointer: coarse)').matches,
    joy:{ move:{active:false,id:null,cx:0,cy:0,vx:0,vy:0}, aim:{active:false,id:null,cx:0,cy:0,vx:0,vy:0} },
    // scene layers
    fog:[], dust:[],
    // entities
    ent:{ bullets:[], enemies:[], towers:[], traps:[], pickups:[], particles:[], floaters:[] },
    // core stats (battle) ‚Äî later parts will enrich
    player:{
      x:2100,y:1400,r:22, speed:330, faceA:0, animT:0,
      hpMax:140,hp:140, shMax:70, sh:35, shRegen:8, shDelay:1100, shHitAt:0,
      gold:0, kills:0,
    },
    combat:{ wave:1, left:0, state:"fight" },
    meta:{ perm:{ atk:0, fir:0, hp:0, gold:0 }, gems:0 }, // Part 5/6
    // hooks/modules
    modules:[],
    hook:{ update:[], draw:[], ui:[] },
  };

  // ----- Canvas resize -----
  ZG.ctx = ZG.canvas.getContext("2d", { alpha:true });
  function resize(){
    ZG.dpr = Math.min(2, devicePixelRatio||1);
    ZG.w = innerWidth; ZG.h = innerHeight;
    ZG.canvas.width  = Math.floor(ZG.w * ZG.dpr);
    ZG.canvas.height = Math.floor(ZG.h * ZG.dpr);
    ZG.canvas.style.width = ZG.w+"px";
    ZG.canvas.style.height= ZG.h+"px";
    ZG.ctx.setTransform(ZG.dpr,0,0,ZG.dpr,0,0);
  }
  addEventListener("resize", resize);
  resize();

  // ----- Input -----
  addEventListener("keydown",(e)=>{
    const k = e.key.toLowerCase();
    ZG.keys.add(k);
    if (k==="p") togglePause();
    if (k===" "){ e.preventDefault(); ZG.hook.ui.forEach(fn=>fn("skill")); }
    if (k==="e"){ ZG.hook.ui.forEach(fn=>fn("shop")); }
  }, {passive:false});
  addEventListener("keyup",(e)=>ZG.keys.delete(e.key.toLowerCase()));
  addEventListener("pointermove",(e)=>{ ZG.mouse.x=e.clientX; ZG.mouse.y=e.clientY; });

  // mobile sticks
  const stickMove = $("stickMove"), stickAim = $("stickAim");
  const knobMove = $("knobMove"), knobAim = $("knobAim");
  if (ZG.isTouch){ stickMove.classList.add("show"); stickAim.classList.add("show"); }
  function bindStick(el, knob, st){
    el.addEventListener("pointerdown",(e)=>{
      st.active=true; st.id=e.pointerId;
      el.setPointerCapture(st.id);
      const r=el.getBoundingClientRect();
      st.cx=r.left+r.width/2; st.cy=r.top+r.height/2;
      upd(e.clientX,e.clientY);
    });
    el.addEventListener("pointermove",(e)=>{
      if(!st.active||e.pointerId!==st.id) return;
      upd(e.clientX,e.clientY);
    });
    el.addEventListener("pointerup",(e)=>{
      if(e.pointerId!==st.id) return;
      st.active=false; st.id=null; st.vx=0; st.vy=0;
      knob.style.transform="translate(0px,0px)";
    });
    function upd(px,py){
      const dx=px-st.cx, dy=py-st.cy;
      const maxR=46;
      const l=Math.hypot(dx,dy);
      const mag = ZG.clamp(l/maxR,0,1);
      const nx=l?dx/l:0, ny=l?dy/l:0;
      st.vx=nx*mag; st.vy=ny*mag;
      knob.style.transform=`translate(${nx*mag*maxR}px,${ny*mag*maxR}px)`;
    }
  }
  bindStick(stickMove, knobMove, ZG.joy.move);
  bindStick(stickAim,  knobAim,  ZG.joy.aim);

  // ----- Scene init -----
  function initScene(){
    ZG.fog.length=0; ZG.dust.length=0;
    for(let i=0;i<26;i++) ZG.fog.push({ x:ZG.rand(0,ZG.world.w), y:ZG.rand(0,ZG.world.h), r:ZG.rand(200,480), vx:ZG.rand(-12,12), vy:ZG.rand(-8,8), a:ZG.rand(0.05,0.12)});
    for(let i=0;i<160;i++) ZG.dust.push({ x:ZG.rand(0,ZG.world.w), y:ZG.rand(0,ZG.world.h), r:ZG.rand(0.8,2.2), vx:ZG.rand(-14,14), vy:ZG.rand(-14,14), a:ZG.rand(0.06,0.20)});
  }
  initScene();

  // ----- UI helpers -----
  function openOverlay(title, note, cards){
    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent = title;
    ZG.ui.modalNote.textContent = note || "";
    ZG.ui.cards.innerHTML = "";
    (cards||[]).forEach(c=>{
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML = `<div class="t">${c.t}</div><div class="d">${c.d||""}</div>`;
      div.onclick = c.on;
      ZG.ui.cards.appendChild(div);
    });
  }
  function closeOverlay(){ ZG.ui.overlay.classList.remove("show"); ZG.ui.cards.innerHTML=""; }
  ZG.ui.modalClose.onclick = closeOverlay;

  function togglePause(){
    ZG.paused = !ZG.paused;
    ZG.ui.btnPause.textContent = ZG.paused ? "ÊöÇÂÅúÔºöÂºÄÔºàPÔºâ" : "ÊöÇÂÅúÔºöÂÖ≥ÔºàPÔºâ";
  }
  ZG.ui.btnPause.onclick = togglePause;

  ZG.ui.btnMeta.onclick = () => {
    ZG.mode = (ZG.mode==="battle") ? "meta" : "battle";
    ZG.ui.mode.textContent = (ZG.mode==="battle") ? "ÊàòÊñó" : "Â±ÄÂ§ñ";
    openOverlay(ZG.mode==="meta" ? "Â±ÄÂ§ñÂÖªÊàêÔºàPart5 ÂÆûË£ÖÔºâ" : "ËøîÂõûÊàòÊñó",
      "‰Ω†Ë¶ÅÁöÑ‚ÄúÂÖªÊàê/ÊäΩÂç°/Âº∫Âåñ/‰ªìÂ∫ì‚ÄùÔºå‰ºöÂú® Part 5/6 Áõ¥Êé•Êé•ËøõÊù•„ÄÇ", []);
  };

  // ----- Core: aim / camera -----
  ZG.getAimWorld = () => {
    if (ZG.isTouch && (Math.abs(ZG.joy.aim.vx)+Math.abs(ZG.joy.aim.vy) > 0.08)){
      const [nx,ny]=ZG.norm(ZG.joy.aim.vx, ZG.joy.aim.vy);
      return { x: ZG.player.x + nx*800, y: ZG.player.y + ny*800 };
    }
    return { x: ZG.mouse.x + ZG.cam.x, y: ZG.mouse.y + ZG.cam.y };
  };

  // ----- Default placeholder draw (Part2 will override with colored sprites) -----
  ZG.hook.draw.push(() => {
    const ctx=ZG.ctx, w=ZG.w, h=ZG.h;
    ctx.clearRect(0,0,w,h);

    // ground grid + scanlines
    const grid=86;
    const ox=-(ZG.cam.x%grid), oy=-(ZG.cam.y%grid);
    ctx.globalAlpha=0.16; ctx.lineWidth=1; ctx.strokeStyle="rgba(255,255,255,.18)";
    for(let x=ox;x<w;x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=oy;y<h;y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    const t=ZG.now()/1000;
    ctx.globalAlpha=0.06; ctx.fillStyle="rgba(255,255,255,.85)";
    for(let k=0;k<5;k++){ const yy=((t*44+k*220)%(h+240))-120; ctx.fillRect(0,yy,w,2); }
    ctx.globalAlpha=1;

    // fog
    for(const f of ZG.fog){
      const px=(f.x-ZG.cam.x*0.92), py=(f.y-ZG.cam.y*0.92);
      if(px<-700||py<-700||px>w+700||py>h+700) continue;
      ctx.globalAlpha=f.a; ctx.beginPath(); ctx.arc(px,py,f.r,0,Math.PI*2); ctx.fillStyle="rgba(255,255,255,.85)"; ctx.fill();
    }
    ctx.globalAlpha=1;

    // dust
    ctx.fillStyle="rgba(255,255,255,.65)";
    for(const d of ZG.dust){
      const x=d.x-ZG.cam.x, y=d.y-ZG.cam.y;
      if(x<0||y<0||x>w||y>h) continue;
      ctx.globalAlpha=d.a; ctx.beginPath(); ctx.arc(x,y,d.r,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;

    // placeholder player
    const px=ZG.player.x-ZG.cam.x, py=ZG.player.y-ZG.cam.y;
    ctx.globalAlpha=0.95; ctx.beginPath(); ctx.arc(px,py,ZG.player.r,0,Math.PI*2); ctx.fillStyle="rgba(255,255,255,.92)"; ctx.fill(); ctx.globalAlpha=1;
    const aim=ZG.getAimWorld(); const [nx,ny]=ZG.norm(aim.x-ZG.player.x, aim.y-ZG.player.y);
    ctx.globalAlpha=0.28; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+nx*260, py+ny*260); ctx.strokeStyle="rgba(255,255,255,.85)"; ctx.lineWidth=2; ctx.stroke(); ctx.globalAlpha=1;
  });

  // ----- Default update (scene + move + camera) -----
  ZG.hook.update.push((dt)=>{
    const s=dt/1000;
    for(const f of ZG.fog){
      f.x+=f.vx*s; f.y+=f.vy*s;
      if(f.x<-250)f.x=ZG.world.w+250; if(f.x>ZG.world.w+250)f.x=-250;
      if(f.y<-250)f.y=ZG.world.h+250; if(f.y>ZG.world.h+250)f.y=-250;
    }
    for(const d of ZG.dust){
      d.x+=d.vx*s; d.y+=d.vy*s;
      if(d.x<0)d.x=ZG.world.w; if(d.x>ZG.world.w)d.x=0;
      if(d.y<0)d.y=ZG.world.h; if(d.y>ZG.world.h)d.y=0;
    }

    // movement
    let mx=0,my=0;
    if(ZG.keys.has("w")||ZG.keys.has("arrowup")) my-=1;
    if(ZG.keys.has("s")||ZG.keys.has("arrowdown")) my+=1;
    if(ZG.keys.has("a")||ZG.keys.has("arrowleft")) mx-=1;
    if(ZG.keys.has("d")||ZG.keys.has("arrowright")) mx+=1;
    if(ZG.isTouch){ mx+=ZG.joy.move.vx; my+=ZG.joy.move.vy; }
    if(mx||my){
      const [nx,ny]=ZG.norm(mx,my);
      ZG.player.x = ZG.clamp(ZG.player.x + nx*ZG.player.speed*s, 0, ZG.world.w);
      ZG.player.y = ZG.clamp(ZG.player.y + ny*ZG.player.speed*s, 0, ZG.world.h);
      ZG.player.animT += s;
    } else ZG.player.animT += s*0.6;

    // face aim
    const aim=ZG.getAimWorld();
    ZG.player.faceA = Math.atan2(aim.y-ZG.player.y, aim.x-ZG.player.x);

    // camera follow + shake
    const sx = (ZG.shake>0)? ZG.rand(-ZG.shake,ZG.shake) : 0;
    const sy = (ZG.shake>0)? ZG.rand(-ZG.shake,ZG.shake) : 0;
    ZG.shake = Math.max(0, ZG.shake-0.9);
    ZG.cam.x = ZG.clamp(ZG.player.x - ZG.w/2 + sx, 0, ZG.world.w - ZG.w);
    ZG.cam.y = ZG.clamp(ZG.player.y - ZG.h/2 + sy, 0, ZG.world.h - ZG.h);
  });

  // ----- UI refresh -----
  ZG.hook.ui.push((evt)=>{
    // placeholder for skill/shop; later parts will handle
    if(evt==="shop"){
      openOverlay("ÂïÜÂ∫óÔºàPart6 ÂÆåÊï¥ÊàêÂìÅÂåñÔºâ", "ÂÖàÂç†‰ΩçÔºöPart3/4/5/6 ‰ºöÊääÂâ≤Ëçâ„ÄÅÂ°îÈò≤„ÄÅÂÖªÊàêÂÖ®Êé•ËøõÊù•„ÄÇ", []);
    }
    if(evt==="skill"){
      ZG.shake = Math.max(ZG.shake, 10);
    }
  });

  // ----- main loop -----
  let last=ZG.now();
  let fpsT=0,fpsC=0,fps=0;
  function tick(t){
    requestAnimationFrame(tick);
    const dt = Math.min(40, t-last); last=t;

    if(!ZG.paused){
      for(const fn of ZG.hook.update) fn(dt);
      for(const fn of ZG.modules) fn(dt); // reserved
    }
    for(const fn of ZG.hook.draw) fn(dt);

    // hud
    ZG.ui.hp.textContent = Math.ceil(ZG.player.hp);
    ZG.ui.hpMax.textContent = Math.ceil(ZG.player.hpMax);
    ZG.ui.sh.textContent = Math.ceil(ZG.player.sh);
    ZG.ui.gold.textContent = ZG.player.gold|0;
    ZG.ui.wave.textContent = ZG.combat.wave|0;
    ZG.ui.left.textContent = ZG.combat.left|0;
    ZG.ui.kills.textContent = ZG.player.kills|0;

    fpsT+=dt; fpsC++;
    if(fpsT>500){ fps=Math.round(fpsC*1000/fpsT); fpsT=0; fpsC=0; ZG.ui.fps.textContent=String(fps); }
  }
  ZG.ui.btnPause.textContent="ÊöÇÂÅúÔºöÂÖ≥ÔºàPÔºâ";
  requestAnimationFrame(tick);
})();
</script>
</body>
  <script>
(() => {
  const ZG = window.ZG; if(!ZG) return;

  // ===== Part2: ÂΩ©Ëâ≤‚ÄúÁ≤æÁÅµÁªòÂà∂‚Äù(Á®ãÂ∫èÁªòÂà∂=ÂΩ©ÂõæÔºå‰∏çÈù†Â§ñÈìæ) =====
  const P = {
    player:{ body:"#38bdf8", head:"#ffd4b8", hair:"#0f172a", pants:"#1f2a44", gun:"#c7d2fe" },
    zWalk :{ body:"#34d399", head:"#b9fbc0", cloth:"#0f172a" },
    zFast :{ body:"#a78bfa", head:"#ddd6fe" },
    zTank :{ body:"#fb923c", head:"#fed7aa" },
    boss  :{ body:"#fb7185", head:"#fecaca" },
  };

  function drawShadow(ctx,r){
    ctx.globalAlpha=0.22;
    ctx.beginPath(); ctx.ellipse(0, r*1.2, r*1.05, r*0.45, 0, 0, Math.PI*2);
    ctx.fillStyle="#000"; ctx.fill(); ctx.globalAlpha=1;
  }

  function drawHumanoid(ctx, r, pal, frame, isZombie=false){
    // frame: 0..5 walk bob
    const bob = Math.sin(frame*0.9)*2.2;
    const legA = Math.sin(frame*0.9)*0.55;
    drawShadow(ctx, r);

    // legs
    ctx.save();
    ctx.translate(0, r*0.55 + bob);
    ctx.strokeStyle = pal.pants || "#1f2a44";
    ctx.lineWidth = r*0.28; ctx.lineCap="round";
    ctx.beginPath(); ctx.moveTo(-r*0.20,0); ctx.lineTo(-r*0.55 + legA*4, r*0.85); ctx.stroke();
    ctx.beginPath(); ctx.moveTo( r*0.20,0); ctx.lineTo( r*0.55 - legA*4, r*0.85); ctx.stroke();
    ctx.restore();

    // body
    ctx.save();
    ctx.translate(0, bob);
    ctx.beginPath(); ctx.arc(0, r*0.10, r*0.70, 0, Math.PI*2);
    ctx.fillStyle = pal.body; ctx.fill();
    ctx.restore();

    // head
    ctx.save();
    ctx.translate(0, -r*0.85 + bob*0.6);
    ctx.beginPath(); ctx.arc(0, 0, r*0.52, 0, Math.PI*2);
    ctx.fillStyle = pal.head; ctx.fill();
    // hair / top
    if(pal.hair){
      ctx.beginPath();
      ctx.moveTo(-r*0.55, -r*0.05);
      ctx.quadraticCurveTo(0, -r*0.95, r*0.55, -r*0.05);
      ctx.closePath();
      ctx.fillStyle = pal.hair; ctx.globalAlpha=0.85; ctx.fill(); ctx.globalAlpha=1;
    }
    // eyes
    ctx.fillStyle="#0b1020"; ctx.globalAlpha=0.7;
    ctx.beginPath(); ctx.arc(-r*0.18, -r*0.05, r*0.09, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*0.18,  0.00, r*0.09, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
    ctx.restore();

    // arms
    ctx.save();
    ctx.translate(0, bob);
    ctx.strokeStyle = pal.head; ctx.lineWidth=r*0.22; ctx.lineCap="round";
    ctx.beginPath(); ctx.moveTo(-r*0.55, 0); ctx.lineTo(-r*0.95, r*0.18 + legA*3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo( r*0.55, 0); ctx.lineTo( r*0.95, r*0.18 - legA*3); ctx.stroke();
    ctx.restore();

    // gun for player only
    if(pal.gun){
      ctx.save();
      ctx.translate(r*0.95, bob*0.7);
      ctx.fillStyle = pal.gun; ctx.globalAlpha=0.95;
      ctx.fillRect(0, -r*0.12, r*0.58, r*0.24);
      ctx.globalAlpha=0.7; ctx.fillStyle="#0b1020";
      ctx.fillRect(r*0.28, -r*0.20, r*0.20, r*0.10);
      ctx.restore();
    }

    // zombie cracks (small)
    if(isZombie){
      ctx.save();
      ctx.translate(0, -r*0.85);
      ctx.strokeStyle="rgba(0,0,0,.18)";
      ctx.lineWidth=r*0.06;
      ctx.beginPath(); ctx.moveTo(-r*0.25, r*0.10); ctx.lineTo(-r*0.40, r*0.30); ctx.stroke();
      ctx.restore();
    }
  }

  function drawBoss(ctx, r, frame){
    const pal=P.boss;
    const bob = Math.sin(frame*0.6)*3.5;
    drawShadow(ctx, r*1.15);

    ctx.save();
    ctx.translate(0, bob);
    // body
    ctx.beginPath(); ctx.arc(0, r*0.10, r*1.05, 0, Math.PI*2);
    ctx.fillStyle = pal.body; ctx.globalAlpha=0.95; ctx.fill(); ctx.globalAlpha=1;

    // head
    ctx.beginPath(); ctx.arc(0, -r*1.05, r*0.65, 0, Math.PI*2);
    ctx.fillStyle = pal.head; ctx.fill();

    // horns
    ctx.globalAlpha=0.55; ctx.fillStyle="#0f172a";
    ctx.beginPath(); ctx.moveTo(-r*0.35, -r*1.75); ctx.lineTo(-r*0.85, -r*1.25); ctx.lineTo(-r*0.25, -r*1.20); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo( r*0.35, -r*1.75); ctx.lineTo( r*0.85, -r*1.25); ctx.lineTo( r*0.25, -r*1.20); ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1;

    // face
    ctx.fillStyle="#0b1020"; ctx.globalAlpha=0.7;
    ctx.beginPath(); ctx.arc(-r*0.18, -r*1.12, r*0.10, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*0.18, -r*1.07, r*0.10, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    // arms
    ctx.strokeStyle = pal.head; ctx.lineWidth=r*0.28; ctx.lineCap="round";
    ctx.beginPath(); ctx.moveTo(-r*1.0, r*0.00); ctx.lineTo(-r*1.45, r*0.40); ctx.stroke();
    ctx.beginPath(); ctx.moveTo( r*1.0, r*0.00); ctx.lineTo( r*1.45, r*0.40); ctx.stroke();

    ctx.restore();
  }

  // demo enemies in part2 (will be replaced by part3 spawner)
  if(ZG.ent.enemies.length===0){
    const c={x:ZG.world.w/2,y:ZG.world.h/2};
    const kinds=["walk","fast","tank","boss"];
    for(let i=0;i<10;i++){
      const k=kinds[i%kinds.length];
      ZG.ent.enemies.push({ kind:k, x:c.x+ZG.rand(-520,520), y:c.y+ZG.rand(-380,380),
        r:(k==="boss")?60:(k==="tank"?36:(k==="fast"?24:26)),
        speed:(k==="boss")?70:(k==="tank"?70:(k==="fast"?170:105)),
        faceA:ZG.rand(0,Math.PI*2), animT:ZG.rand(0,10),
        hp:100,hpMax:100 });
    }
  }

  // override draw hook: insert colored sprites after scene draw, but keep scene from Part1
  // We do it by pushing a draw hook that draws entities after Part1 background.
  ZG.hook.draw.push(() => {
    const ctx=ZG.ctx, w=ZG.w, h=ZG.h;

    // draw enemies
    for(const e of ZG.ent.enemies){
      // demo follow
      const dx=ZG.player.x-e.x, dy=ZG.player.y-e.y;
      const [nx,ny]=ZG.norm(dx,dy);
      e.x += nx*e.speed*0.016;
      e.y += ny*e.speed*0.016;
      e.faceA = Math.atan2(ny,nx);
      e.animT += 0.016;

      const sx=e.x-ZG.cam.x, sy=e.y-ZG.cam.y;
      if(sx<-200||sy<-200||sx>w+200||sy>h+200) continue;

      ctx.save();
      ctx.translate(sx,sy);
      ctx.rotate(e.faceA);
      const f=e.animT*10;
      if(e.kind==="boss") drawBoss(ctx, e.r, f);
      else if(e.kind==="tank") drawHumanoid(ctx, e.r, P.zTank, f, true);
      else if(e.kind==="fast") drawHumanoid(ctx, e.r, P.zFast, f, true);
      else drawHumanoid(ctx, e.r, P.zWalk, f, true);
      ctx.restore();

      // hp bar
      const bw=e.r*2.0, bh=7;
      const hpP=ZG.clamp(e.hp/e.hpMax,0,1);
      ctx.globalAlpha=0.75;
      ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(sx-bw/2, sy-e.r-24, bw, bh);
      ctx.fillStyle="rgba(255,255,255,.72)"; ctx.fillRect(sx-bw/2, sy-e.r-24, bw*hpP, bh);
      ctx.globalAlpha=1;
    }

    // draw player (replaces white dot visually ‚Äî we just draw on top)
    const px=ZG.player.x-ZG.cam.x, py=ZG.player.y-ZG.cam.y;
    ctx.save();
    ctx.translate(px,py);
    ctx.rotate(ZG.player.faceA);
    drawHumanoid(ctx, ZG.player.r, P.player, ZG.player.animT*10, false);
    ctx.restore();
  });
})();
</script>
<script>
(() => {
  const ZG = window.ZG; if(!ZG) return;

  // ===== Part3: Roguelike Survivors Combat =====
  // remove demo enemies
  ZG.ent.enemies.length = 0;

  const combat = ZG.combat;
  combat.wave = 1;
  combat.left = 0;
  combat.state = "fight";

  // weapon + build
  const WPN = {
    AR:{ name:"Ê≠•Êû™", rpm:760, dmg:15, spread:0.05, speed:1100, pierce:0, burst:1 },
    SG:{ name:"Èú∞Âºπ", rpm:130, dmg:10, spread:0.35, speed:950,  pierce:0, burst:7 },
    LAS:{name:"ÊøÄÂÖâ", rpm:260, dmg:7,  spread:0.02, speed:1400, pierce:2, burst:1 },
  };
  ZG.build = {
    wpn:"AR",
    dmgMul:1, fireMul:1, speedMul:1,
    pierceAdd:0, splash:0, chain:0,
    crit:0.12, critMul:1.85,
    freeze:0, burn:0,
    magnet:170,
    skillCd:10500, skillT:0,
  };

  function dps(){
    const w=WPN[ZG.build.wpn];
    const sps=(w.rpm/60)*ZG.build.fireMul;
    return Math.floor(sps*w.dmg*ZG.build.dmgMul*w.burst);
  }

  // spawner
  function startWave(n){
    combat.wave=n; ZG.ui.wave.textContent=String(n);
    combat.state="fight";
    const boss = (n%5===0);
    combat.left = Math.floor(22 + n*7 + (boss?1:0));
    ZG.ui.left.textContent=String(combat.left);
    combat.spawnRate = Math.max(0.20, 0.92 - n*0.032);
    combat.spawnT = 0;
    combat.bossPending = boss;
  }
  startWave(1);

  function spawnEnemy(kind){
    const ang=ZG.rand(0,Math.PI*2);
    const dist=ZG.rand(720,980);
    const x=ZG.clamp(ZG.player.x+Math.cos(ang)*dist, 0, ZG.world.w);
    const y=ZG.clamp(ZG.player.y+Math.sin(ang)*dist, 0, ZG.world.h);

    const n=combat.wave;
    const baseHp = 54 + n*13;
    const e={ kind, x,y, faceA:0, animT:ZG.rand(0,10), hit:0, frozen:0, burn:0 };
    if(kind==="walk"){ e.r=26; e.speed=105+n*2.6; e.hp=e.hpMax=baseHp; e.dmg=14; }
    if(kind==="fast"){ e.r=24; e.speed=170+n*3.2; e.hp=e.hpMax=38+n*10; e.dmg=12; }
    if(kind==="tank"){ e.r=36; e.speed=70+n*1.4;  e.hp=e.hpMax=170+n*34; e.dmg=22; }
    if(kind==="boss"){ e.r=60; e.speed=70+n*1.1;  e.hp=e.hpMax=1300+n*250; e.dmg=28; e.boss=true; e.summonT=1700; e.slamT=1900; }
    ZG.ent.enemies.push(e);
  }

  // bullets / pickups / particles are already in ent
  function fire(dt){
    const w=WPN[ZG.build.wpn];
    const sps=(w.rpm/60)*ZG.build.fireMul;
    const cd=1000/Math.max(0.001,sps);
    ZG.build.fireT=(ZG.build.fireT||0)-dt;
    if(ZG.build.fireT>0) return;
    ZG.build.fireT=cd;

    // aim at nearest
    let tx=ZG.getAimWorld().x, ty=ZG.getAimWorld().y;
    if(ZG.ent.enemies.length){
      let best=null,bd=1e18;
      for(const e of ZG.ent.enemies){
        const d=(e.x-ZG.player.x)**2+(e.y-ZG.player.y)**2;
        if(d<bd){ bd=d; best=e; }
      }
      if(best){ tx=best.x; ty=best.y; }
    }
    const [nx,ny]=ZG.norm(tx-ZG.player.x, ty-ZG.player.y);
    const baseA=Math.atan2(ny,nx);
    ZG.player.faceA=baseA;

    for(let i=0;i<w.burst;i++){
      const a=baseA + (Math.random()*2-1)*w.spread;
      ZG.ent.bullets.push({
        x:ZG.player.x+Math.cos(a)*(ZG.player.r+14),
        y:ZG.player.y+Math.sin(a)*(ZG.player.r+14),
        vx:Math.cos(a)*w.speed,
        vy:Math.sin(a)*w.speed,
        r:4.5,
        life:1.15,
        dmg:w.dmg*ZG.build.dmgMul,
        pierce:w.pierce+ZG.build.pierceAdd,
      });
    }
  }

  function hurtEnemy(e, dmg, from){
    const crit = (Math.random() < ZG.build.crit);
    const fin = crit ? dmg*ZG.build.critMul : dmg;
    e.hp -= fin; e.hit=0.08;

    // status
    if(ZG.build.freeze>0 && Math.random()<ZG.build.freeze) e.frozen=Math.max(e.frozen,0.75);
    if(ZG.build.burn>0   && Math.random()<ZG.build.burn)   e.burn=Math.max(e.burn,1.45);

    // float text
    ZG.ent.floaters.push({ x:e.x, y:e.y-e.r-10, vy:-40, life:0.85, a:1, text:(crit?"‚ú¶ ":"")+Math.floor(fin) });

    // chain lightning
    if(ZG.build.chain>0 && Math.random()<0.55){
      let cur=e;
      for(let i=0;i<ZG.build.chain;i++){
        let best=null,bd=1e18;
        for(const ee of ZG.ent.enemies){
          if(ee===cur) continue;
          const d=(ee.x-cur.x)**2+(ee.y-cur.y)**2;
          if(d<bd && d<280*280){ bd=d; best=ee; }
        }
        if(!best) break;
        // lightning particles line
        for(let k=0;k<12;k++){
          const t=k/12;
          ZG.ent.particles.push({ x:ZG.lerp(cur.x,best.x,t)+ZG.rand(-6,6), y:ZG.lerp(cur.y,best.y,t)+ZG.rand(-6,6), vx:0,vy:0,r:ZG.rand(1.1,2.4), a:1, life:ZG.rand(0.06,0.12) });
        }
        best.hp -= fin*0.45;
        cur=best;
      }
    }

    // splash
    if(ZG.build.splash>0){
      const R=ZG.build.splash;
      for(const ee of ZG.ent.enemies){
        if(ee===e) continue;
        const d=Math.hypot(ee.x-e.x, ee.y-e.y);
        if(d<R) ee.hp -= fin*0.25;
      }
    }
  }

  function bulletsUpdate(dt){
    for(let i=ZG.ent.bullets.length-1;i>=0;i--){
      const b=ZG.ent.bullets[i];
      b.x += b.vx*dt/1000;
      b.y += b.vy*dt/1000;
      b.life -= dt/1000;
      if(b.life<=0){ ZG.ent.bullets.splice(i,1); continue; }

      for(let j=ZG.ent.enemies.length-1;j>=0;j--){
        const e=ZG.ent.enemies[j];
        const d=Math.hypot(b.x-e.x, b.y-e.y);
        if(d < b.r + e.r){
          hurtEnemy(e, b.dmg, "bullet");
          b.pierce--;
          if(b.pierce<0){ ZG.ent.bullets.splice(i,1); }
          break;
        }
      }
    }
  }

  function enemyUpdate(dt){
    const s=dt/1000;
    for(let i=ZG.ent.enemies.length-1;i>=0;i--){
      const e=ZG.ent.enemies[i];
      e.animT += s*1.0;
      if(e.hit>0) e.hit -= s;
      if(e.frozen>0) e.frozen -= s;
      if(e.burn>0){
        e.burn -= s;
        if(Math.random()<0.18) e.hp -= (2.0 + combat.wave*0.06);
      }

      // boss abilities (slam/summon)
      if(e.boss){
        e.summonT -= dt; e.slamT -= dt;
        if(e.summonT<=0){ e.summonT=ZG.rand(1400,1900); for(let k=0;k<2;k++) spawnEnemy(Math.random()<0.5?"fast":"walk"); }
        if(e.slamT<=0){ e.slamT=ZG.rand(1600,2300); ZG.ent.traps.push({ type:"slam", x:e.x, y:e.y, r:160, t:0, life:0.95, dmg:18+combat.wave*0.75 }); }
      }

      const dx=ZG.player.x-e.x, dy=ZG.player.y-e.y;
      const [nx,ny]=ZG.norm(dx,dy);
      const slow = e.frozen>0 ? 0.45 : 1;
      e.x += nx*e.speed*slow*s;
      e.y += ny*e.speed*slow*s;
      e.faceA = Math.atan2(ny,nx);

      // collide player
      const dist=Math.hypot(ZG.player.x-e.x, ZG.player.y-e.y);
      if(dist < ZG.player.r + e.r){
        hitPlayer(e.dmg);
        e.x -= nx*10; e.y -= ny*10;
      }

      // death
      if(e.hp<=0){
        ZG.player.kills++;
        dropLoot(e);
        ZG.shake = Math.max(ZG.shake, 12);
        for(let k=0;k<22;k++) ZG.ent.particles.push({ x:e.x, y:e.y, vx:ZG.rand(-260,260), vy:ZG.rand(-260,260), r:ZG.rand(1.6,4.2), a:1, life:ZG.rand(0.22,0.60) });
        ZG.ent.enemies.splice(i,1);
      }
    }
  }

  function hitPlayer(dmg){
    ZG.player.shHitAt = ZG.now();
    let left=dmg;
    if(ZG.player.sh>0){ const use=Math.min(ZG.player.sh,left); ZG.player.sh-=use; left-=use; }
    if(left>0){ ZG.player.hp = ZG.clamp(ZG.player.hp-left,0,ZG.player.hpMax); }
    ZG.ent.floaters.push({ x:ZG.player.x, y:ZG.player.y-48, vy:-40, life:0.85, a:1, text:"-"+Math.floor(dmg) });
    ZG.shake = Math.max(ZG.shake, 9);
    if(ZG.player.hp<=0) gameOver();
  }

  function dropLoot(e){
    const gBase = e.boss?22:(e.kind==="tank"?7:(e.kind==="fast"?3:5));
    const g = Math.floor(gBase*(1+ZG.meta.perm.gold*0.05));
    ZG.ent.pickups.push({ x:e.x, y:e.y, r:9, type:"gold", val:g });
    if(Math.random()<0.10) ZG.ent.pickups.push({ x:e.x+ZG.rand(-10,10), y:e.y+ZG.rand(-10,10), r:8, type:"heal", val:12 });
  }

  function pickupsUpdate(dt){
    const s=dt/1000;
    const mag = ZG.build.magnet;
    for(let i=ZG.ent.pickups.length-1;i>=0;i--){
      const p=ZG.ent.pickups[i];
      const dx=ZG.player.x-p.x, dy=ZG.player.y-p.y;
      const d=Math.hypot(dx,dy);
      if(d<mag){
        const [nx,ny]=ZG.norm(dx,dy);
        p.x += nx*(420+(mag-d)*3)*s;
        p.y += ny*(420+(mag-d)*3)*s;
      }
      if(d<ZG.player.r+p.r+6){
        if(p.type==="gold") ZG.player.gold += p.val;
        if(p.type==="heal") ZG.player.hp = ZG.clamp(ZG.player.hp+p.val,0,ZG.player.hpMax);
        ZG.ent.pickups.splice(i,1);
      }
    }
  }

  function trapsUpdate(dt){
    const s=dt/1000;
    for(let i=ZG.ent.traps.length-1;i>=0;i--){
      const t=ZG.ent.traps[i];
      t.life -= s;
      if(t.type==="slam"){ t.t += s; if(!t.did && t.t>0.66){ t.did=true; if(Math.hypot(ZG.player.x-t.x, ZG.player.y-t.y)<t.r) hitPlayer(t.dmg); ZG.shake=Math.max(ZG.shake,18); } }
      if(t.life<=0) ZG.ent.traps.splice(i,1);
    }
  }

  function particlesUpdate(dt){
    const s=dt/1000;
    for(let i=ZG.ent.particles.length-1;i>=0;i--){
      const p=ZG.ent.particles[i];
      p.life -= s; if(p.life<=0){ ZG.ent.particles.splice(i,1); continue; }
      p.x += (p.vx||0)*s; p.y += (p.vy||0)*s;
      p.a = ZG.clamp(p.life*3,0,1);
    }
    for(let i=ZG.ent.floaters.length-1;i>=0;i--){
      const f=ZG.ent.floaters[i];
      f.life -= s; if(f.life<=0){ ZG.ent.floaters.splice(i,1); continue; }
      f.y += f.vy*s; f.a = ZG.clamp(f.life*1.6,0,1);
    }
  }

  function shieldRegen(dt){
    const s=dt/1000;
    if(ZG.now() - ZG.player.shHitAt > ZG.player.shDelay){
      ZG.player.sh = ZG.clamp(ZG.player.sh + ZG.player.shRegen*s, 0, ZG.player.shMax);
    }
  }

  // skill: EMP storm
  function doSkill(){
    if(ZG.build.skillT>0) return;
    ZG.build.skillT = ZG.build.skillCd;
    const R=320;
    ZG.ent.traps.push({ type:"storm", x:ZG.player.x, y:ZG.player.y, r:R, t:0, life:0.85 });
    ZG.shake=Math.max(ZG.shake,18);
    for(const e of ZG.ent.enemies){
      if(Math.hypot(e.x-ZG.player.x, e.y-ZG.player.y) < R){
        e.frozen = Math.max(e.frozen, 1.1);
        hurtEnemy(e, 34 + combat.wave*1.7, "skill");
      }
    }
  }

  // wave spawner
  function spawnUpdate(dt){
    if(combat.state!=="fight") return;
    combat.spawnT -= dt;
    if(combat.spawnT>0) return;
    if(combat.left<=0) return;
    combat.spawnT = combat.spawnRate*1000;
    const n=combat.wave;
    if(combat.bossPending && combat.left===1){ spawnEnemy("boss"); combat.left--; return; }
    const r=Math.random();
    let kind="walk";
    if(r<Math.min(0.12,0.05+n*0.006)) kind="tank";
    else if(r<Math.min(0.58,0.22+n*0.012)) kind="fast";
    spawnEnemy(kind);
    combat.left--;
  }

  function checkWaveEnd(){
    if(combat.state!=="fight") return;
    if(combat.left<=0 && ZG.ent.enemies.length===0){
      combat.state="between";
      openUpgrades();
    }
  }

  // upgrades (3-choice)
  const upgrades = [
    {t:"üî• Â∞ÑÈÄü +20%", d:"Êõ¥ÁàΩÊõ¥Âø´Ê∏ÖÊÄ™", on:()=>ZG.build.fireMul*=1.2},
    {t:"üí• ‰º§ÂÆ≥ +25%", d:"BossÊõ¥Â•ΩÊâì", on:()=>ZG.build.dmgMul*=1.25},
    {t:"üó°Ô∏è Á©øÈÄè +1", d:"Áõ¥Á∫øÂâ≤Ëçâ", on:()=>ZG.build.pierceAdd+=1},
    {t:"üí£ Ê∫ÖÂ∞Ñ +45", d:"Áæ§ÊÄ™ÁàÜÁÇ∏ÊÑü", on:()=>ZG.build.splash+=45},
    {t:"‚ö° ËøûÈîÅÈó™Áîµ +1", d:"ÊàêÂìÅÂë≥ÂæàÂº∫", on:()=>ZG.build.chain+=1},
    {t:"üéØ Êö¥Âáª +6%", d:"ÁàÜÂèëÊõ¥ÁàΩ", on:()=>ZG.build.crit=ZG.clamp(ZG.build.crit+0.06,0,0.70)},
    {t:"‚ùÑÔ∏è ÂÜ∞ÂÜª +12%", d:"ÊéßÂú∫Êõ¥Á®≥", on:()=>ZG.build.freeze=ZG.clamp(ZG.build.freeze+0.12,0,0.60)},
    {t:"üî• ÁÅºÁÉß +12%", d:"Âù¶ÂÖãÊÄ™Êõ¥Â•ΩÁ£®", on:()=>ZG.build.burn=ZG.clamp(ZG.build.burn+0.12,0,0.60)},
    {t:"üß≤ ÊãæÂèñËåÉÂõ¥ +70", d:"ÈáëÂ∏Å/Ë°•ÁªôÊõ¥‰∏ùÊªë", on:()=>ZG.build.magnet+=70},
    {t:"ü©∏ ÊúÄÂ§ßÁîüÂëΩ +40", d:"ÂÆπÈîôÊõ¥È´ò", on:()=>{ZG.player.hpMax+=40; ZG.player.hp=ZG.player.hpMax;}},
    {t:"üõ°Ô∏è Êä§Áõæ‰∏äÈôê +35", d:"Êõ¥ËÄêÊâì", on:()=>{ZG.player.shMax+=35; ZG.player.sh+=25;}},
  ];

  function openUpgrades(){
    const pool=[...upgrades];
    const picks=[];
    while(picks.length<3 && pool.length){
      picks.push(pool.splice(Math.floor(Math.random()*pool.length),1)[0]);
    }
    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent = `Á¨¨ ${combat.wave} Ê≥¢ÁªìÊùüÔºöÈÄâÊã© 1 ‰∏™Âº∫Âåñ`;
    ZG.ui.modalNote.textContent = "ËøôÂ∞±ÊòØÊàêÂìÅËÇâÈ∏ΩÂçáÁ∫ßËäÇÂ•èÔºàÂâ≤ËçâÁ∫øÔºâ„ÄÇ‰∏ã‰∏ÄÊÆµ‰ºöÂä†ÂÖ•‚ÄúÂ°îÈò≤Á∫ø‚Äù„ÄÇ";
    ZG.ui.cards.innerHTML="";
    picks.forEach(u=>{
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML=`<div class="t">${u.t}</div><div class="d">${u.d}</div>`;
      div.onclick=()=>{
        u.on();
        ZG.ui.overlay.classList.remove("show");
        startWave(combat.wave+1);
        combat.state="fight";
      };
      ZG.ui.cards.appendChild(div);
    });
  }

  function gameOver(){
    ZG.paused=true;
    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent="Game Over";
    ZG.ui.modalNote.textContent=`ÂáªÊùÄ ${ZG.player.kills}ÔΩúÂà∞ËææÊ≥¢Ê¨° ${combat.wave}ÔΩúÈáëÂ∏Å ${ZG.player.gold}`;
    ZG.ui.cards.innerHTML="";
    const div=document.createElement("div");
    div.className="card";
    div.innerHTML=`<div class="t">ÈáçÊñ∞ÂºÄÂßã</div><div class="d">Âà∑Êñ∞È°µÈù¢ÂÜçÊù•ÔºàPart5‰ºöÂä†ÂÖ•Â±ÄÂ§ñÂÖªÊàê‰øùÂ≠òÔºâ</div>`;
    div.onclick=()=>location.reload();
    ZG.ui.cards.appendChild(div);
  }

  // shop hook (simple)
  function openShop(){
    const items=[
      {t:"ÂàáÊç¢ÔºöÈú∞ÂºπÊû™", d:"ËøëË∑ùÁàÜÂèëÔºà7ÂèëÔºâ", cost:90, on:()=>ZG.build.wpn="SG"},
      {t:"ÂàáÊç¢ÔºöÊøÄÂÖâÊû™", d:"Á©øÈÄèÊõ¥Âº∫", cost:110, on:()=>ZG.build.wpn="LAS"},
      {t:"ÂàáÊç¢ÔºöÊ≠•Êû™", d:"ÂùáË°°Á®≥ÂÆö", cost:60, on:()=>ZG.build.wpn="AR"},
      {t:"ÊÄ•ÊïëÂåÖ +50HP", d:"Á´ãÂàªÂõûÂ§çÁîüÂëΩ", cost:58, on:()=>ZG.player.hp=ZG.clamp(ZG.player.hp+50,0,ZG.player.hpMax)},
      {t:"Êä§ÁõæÂÖÖËÉΩ +45", d:"Á´ãÂàªÂõûÂ§çÊä§Áõæ", cost:58, on:()=>ZG.player.sh=ZG.clamp(ZG.player.sh+45,0,ZG.player.shMax)},
      {t:"ÊäÄËÉΩÂÜ∑Âç¥ -10%", d:"Êõ¥È¢ëÁπÅÊîæÂ§ßÊãõ", cost:120, on:()=>ZG.build.skillCd=Math.max(4200, ZG.build.skillCd*0.9)},
    ];
    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent="ÂïÜÂ∫óÔºàÊàòÊñó‰∏≠‰πüÂèØÂºÄÔºâ";
    ZG.ui.modalNote.textContent="ËøôÊòØÂâ≤ËçâÁ∫øÂïÜÂ∫óÔºõPart4‰ºöÂä†ÂÖ•Â°îÈò≤Âª∫ÈÄ†/ÂçáÁ∫ß„ÄÇ";
    ZG.ui.cards.innerHTML="";
    items.forEach(it=>{
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML=`<div class="t">${it.t}Ôºà${it.cost}üí∞Ôºâ</div><div class="d">${it.d}</div>`;
      div.onclick=()=>{
        if(ZG.player.gold<it.cost) return;
        ZG.player.gold-=it.cost;
        it.on();
      };
      ZG.ui.cards.appendChild(div);
    });
  }

  // hook ui events
  ZG.hook.ui.push((evt)=>{
    if(evt==="skill") doSkill();
    if(evt==="shop") openShop();
  });
  ZG.ui.btnSkill.onclick = doSkill;
  ZG.ui.btnShop.onclick = openShop;

  // combat update module
  ZG.modules.push((dt)=>{
    if(ZG.paused) return;

    // skill cd
    if(ZG.build.skillT>0) ZG.build.skillT = Math.max(0, ZG.build.skillT-dt);

    // regen
    shieldRegen(dt);

    // spawn & fight
    spawnUpdate(dt);
    fire(dt);
    bulletsUpdate(dt);
    trapsUpdate(dt);
    enemyUpdate(dt);
    pickupsUpdate(dt);
    particlesUpdate(dt);
    checkWaveEnd();

    ZG.ui.dps.textContent = String(dps());
  });

  // draw bullets/pickups/particles/floaters on top (keeps Part2 sprites)
  ZG.hook.draw.push(() => {
    const ctx=ZG.ctx;
    const toX=(x)=>x-ZG.cam.x, toY=(y)=>y-ZG.cam.y;

    // traps visuals
    for(const t of ZG.ent.traps){
      const x=toX(t.x), y=toY(t.y);
      if(t.type==="storm"){
        ctx.globalAlpha=0.18;
        ctx.beginPath(); ctx.arc(x,y,t.r,0,Math.PI*2);
        ctx.strokeStyle="rgba(255,255,255,.95)"; ctx.lineWidth=3; ctx.stroke(); ctx.globalAlpha=1;
      }
      if(t.type==="slam"){
        const p=ZG.clamp((t.t||0)/0.66,0,1);
        ctx.globalAlpha=0.28;
        ctx.beginPath(); ctx.arc(x,y,t.r*p,0,Math.PI*2);
        ctx.strokeStyle="rgba(255,255,255,.9)"; ctx.lineWidth=3; ctx.stroke(); ctx.globalAlpha=1;
      }
    }

    // bullets
    for(const b of ZG.ent.bullets){
      const x=toX(b.x), y=toY(b.y);
      ctx.globalAlpha=0.25; ctx.beginPath(); ctx.arc(x,y,b.r*3.0,0,Math.PI*2); ctx.fillStyle="rgba(255,255,255,.85)"; ctx.fill();
      ctx.globalAlpha=0.92; ctx.beginPath(); ctx.arc(x,y,b.r,0,Math.PI*2); ctx.fillStyle="rgba(255,255,255,.95)"; ctx.fill();
      ctx.globalAlpha=1;
    }

    // pickups
    for(const p of ZG.ent.pickups){
      const x=toX(p.x), y=toY(p.y);
      ctx.globalAlpha=0.9; ctx.beginPath(); ctx.arc(x,y,p.r,0,Math.PI*2);
      ctx.fillStyle = (p.type==="gold") ? "rgba(255,215,130,.95)" : "rgba(180,255,220,.85)";
      ctx.fill(); ctx.globalAlpha=1;
    }

    // particles
    for(const p of ZG.ent.particles){
      const x=toX(p.x), y=toY(p.y);
      ctx.globalAlpha=p.a;
      ctx.beginPath(); ctx.arc(x,y,p.r,0,Math.PI*2);
      ctx.fillStyle="rgba(255,255,255,.88)"; ctx.fill();
    }
    ctx.globalAlpha=1;

    // floaters
    ctx.font="900 14px system-ui";
    for(const f of ZG.ent.floaters){
      const x=toX(f.x), y=toY(f.y);
      ctx.globalAlpha=f.a;
      ctx.fillStyle="rgba(255,255,255,.95)";
      ctx.fillText(f.text, x-10, y);
    }
    ctx.globalAlpha=1;
  });
})();
</script>
<script>
(() => {
  const ZG = window.ZG; if(!ZG) return;

  // ===== Part4: Tower Defense Layer =====
  // Âõ∫ÂÆö‚ÄúÂÆàÁÇπË∑ØÁ∫ø‚Äù+ ÂèØÂçáÁ∫ßÁÇÆÂ°îÔºàÊàêÂìÅÂ∏∏ËßÅÔºâ
  const TD = ZG.td = {
    base:{ x: ZG.world.w*0.5, y: ZG.world.h*0.5, r: 80, hp: 400, hpMax: 400 },
    towers: ZG.ent.towers,
    traps:  ZG.ent.traps,
  };

  // place some tower slots around base
  function initTowers(){
    TD.towers.length=0;
    const b=TD.base;
    const slots = [
      {x:b.x-220,y:b.y-120},{x:b.x+220,y:b.y-120},
      {x:b.x-240,y:b.y+140},{x:b.x+240,y:b.y+140},
      {x:b.x,y:b.y-260},{x:b.x,y:b.y+260},
    ];
    slots.forEach((s,i)=>TD.towers.push({ id:i, x:s.x, y:s.y, r:22, lv:0, fireT:0, type:"gun" }));
  }
  initTowers();

  function towerDps(lv){ return 10 + lv*8; }
  function towerRate(lv){ return Math.max(0.18, 0.52 - lv*0.06); } // seconds
  function towerRange(lv){ return 320 + lv*28; }

  function towerUpdate(dt){
    const s=dt/1000;
    for(const t of TD.towers){
      if(t.lv<=0) continue;
      t.fireT -= s;
      if(t.fireT>0) continue;
      // pick nearest enemy in range
      let best=null, bd=1e18;
      const R=towerRange(t.lv);
      for(const e of ZG.ent.enemies){
        const d=(e.x-t.x)**2+(e.y-t.y)**2;
        if(d<bd && d<R*R){ bd=d; best=e; }
      }
      if(!best) continue;
      t.fireT = towerRate(t.lv);

      // fire a bullet towards enemy (uses same bullet system)
      const [nx,ny]=ZG.norm(best.x-t.x, best.y-t.y);
      ZG.ent.bullets.push({
        x:t.x+nx*(t.r+6), y:t.y+ny*(t.r+6),
        vx:nx*1050, vy:ny*1050,
        r:4.0, life:0.9,
        dmg: towerDps(t.lv) * (1+ZG.meta.perm.atk*0.06),
        pierce:0
      });
      // small muzzle particles
      for(let k=0;k<2;k++) ZG.ent.particles.push({ x:t.x+nx*(t.r+8)+ZG.rand(-3,3), y:t.y+ny*(t.r+8)+ZG.rand(-3,3), vx:nx*ZG.rand(80,140), vy:ny*ZG.rand(80,140), r:ZG.rand(1.4,2.8), a:1, life:ZG.rand(0.10,0.18) });
    }
  }

  // base damage when enemies reach core
  function baseCheck(){
    const b=TD.base;
    for(let i=ZG.ent.enemies.length-1;i>=0;i--){
      const e=ZG.ent.enemies[i];
      const d=Math.hypot(e.x-b.x, e.y-b.y);
      if(d < b.r + e.r){
        b.hp -= (e.dmg*0.8);
        ZG.shake=Math.max(ZG.shake,12);
        ZG.ent.floaters.push({ x:b.x, y:b.y-b.r-10, vy:-40, life:0.85, a:1, text:"Ê†∏ÂøÉ-"+Math.floor(e.dmg*0.8) });
        // remove enemy on impact
        ZG.ent.enemies.splice(i,1);
      }
    }
    if(b.hp<=0){
      // force game over
      ZG.player.hp = 0;
    }
  }

  // slow trap: ice field around base (buy/upgrade)
  if(!ZG.td.ice){ ZG.td.ice = { lv:0 }; }
  function applySlowField(dt){
    const lv = ZG.td.ice.lv;
    if(lv<=0) return;
    const b=TD.base;
    const R = 260 + lv*50;
    // visual ring
    ZG.ent.traps.push({ type:"iceRing", x:b.x, y:b.y, r:R, t:0, life:0.06 });
    for(const e of ZG.ent.enemies){
      if(Math.hypot(e.x-b.x, e.y-b.y) < R){
        e.frozen = Math.max(e.frozen, 0.25 + lv*0.12);
      }
    }
  }

  // UI: open tower build menu via Shop
  function openBuildMenu(){
    const cards=[];
    // towers
    for(const t of TD.towers){
      const cost = (t.lv+1)*80;
      cards.push({
        t:`ÁÇÆÂ°îÊßΩ #${t.id}ÔºöÂçáÁ∫ßÂà∞ Lv.${t.lv+1}Ôºà${cost}üí∞Ôºâ`,
        d:`DPS‚âà${towerDps(t.lv+1)}ÔΩúÂ∞ÑÈÄü‚âà${towerRate(t.lv+1)}sÔΩúËåÉÂõ¥‚âà${towerRange(t.lv+1)}`,
        on:()=>{
          if(ZG.player.gold<cost) return;
          ZG.player.gold-=cost;
          t.lv++;
        }
      });
    }
    const iceCost = (ZG.td.ice.lv+1)*120;
    cards.push({
      t:`ÂÜ∞ÈúúÂáèÈÄüÂú∫ÔºöÂçáÁ∫ßÂà∞ Lv.${ZG.td.ice.lv+1}Ôºà${iceCost}üí∞Ôºâ`,
      d:`ÂáèÈÄüËåÉÂõ¥Êâ©Â§ßÔºåÂÆàÁÇπÊõ¥Á®≥ÔºàÂ°îÈò≤Á∫øÊ†∏ÂøÉÔºâ`,
      on:()=>{
        if(ZG.player.gold<iceCost) return;
        ZG.player.gold-=iceCost;
        ZG.td.ice.lv++;
      }
    });

    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent="Â°îÈò≤Âª∫ÈÄ†/ÂçáÁ∫ßÔºàÂÆàÁÇπÁ∫øÔºâ";
    ZG.ui.modalNote.textContent="‰Ω†Áé∞Âú®ÂêåÊó∂Êã•ÊúâÔºöÂâ≤ËçâÂ∞ÑÂáª + ÂÆàÁÇπÁÇÆÂ°î„ÄÇ‰∏ã‰∏ÄÊÆµÂä†ÂÖ•‚ÄúÂ±ÄÂ§ñÂÖªÊàêÔºàÊäΩÂç°/Âº∫Âåñ/Â≠òÊ°£Ôºâ‚Äù„ÄÇ";
    ZG.ui.cards.innerHTML="";
    cards.forEach(c=>{
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML=`<div class="t">${c.t}</div><div class="d">${c.d||""}</div>`;
      div.onclick=c.on;
      ZG.ui.cards.appendChild(div);
    });
  }

  // Hook shop button: add a second page (build)
  const oldShop = ZG.ui.btnShop.onclick;
  ZG.ui.btnShop.onclick = () => {
    // ÁÆÄÂçïÔºöÊåâ‰Ωè Shift ÊâìÂºÄÂ°îÈò≤ËèúÂçïÔºàPCÔºâÔºåÊâãÊú∫Â∞±Áõ¥Êé•ÂºπÂèåÂç°
    if(ZG.keys.has("shift")){
      openBuildMenu();
    } else {
      oldShop && oldShop();
    }
  };

  // Update module
  ZG.modules.push((dt)=>{
    if(ZG.paused) return;
    towerUpdate(dt);
    applySlowField(dt);
    baseCheck();
  });

  // Draw base + towers + ice ring
  ZG.hook.draw.push(()=>{
    const ctx=ZG.ctx;
    const toX=(x)=>x-ZG.cam.x, toY=(y)=>y-ZG.cam.y;

    const b=TD.base;
    const bx=toX(b.x), by=toY(b.y);

    // base glow
    ctx.globalAlpha=0.16;
    ctx.beginPath(); ctx.arc(bx,by,b.r*2.1,0,Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,.75)"; ctx.fill();
    ctx.globalAlpha=0.85;
    ctx.beginPath(); ctx.arc(bx,by,b.r,0,Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,.88)"; ctx.fill();
    ctx.globalAlpha=1;

    // base hp bar
    const hpP = ZG.clamp(b.hp/b.hpMax,0,1);
    ctx.globalAlpha=0.75;
    ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(bx-70, by-b.r-34, 140, 8);
    ctx.fillStyle="rgba(255,255,255,.72)"; ctx.fillRect(bx-70, by-b.r-34, 140*hpP, 8);
    ctx.globalAlpha=1;

    // towers
    for(const t of TD.towers){
      const x=toX(t.x), y=toY(t.y);
      ctx.globalAlpha=0.9;
      ctx.beginPath(); ctx.arc(x,y,t.r,0,Math.PI*2);
      ctx.fillStyle = t.lv>0 ? "rgba(180,255,220,.90)" : "rgba(255,255,255,.22)";
      ctx.fill();
      ctx.globalAlpha=0.8;
      ctx.font="900 12px system-ui";
      ctx.fillStyle="rgba(0,0,0,.55)";
      ctx.fillText(`Lv${t.lv}`, x-12, y+4);
      ctx.globalAlpha=1;
    }

    // ice ring visual (persistent)
    if(ZG.td.ice.lv>0){
      const R=260+ZG.td.ice.lv*50;
      ctx.globalAlpha=0.18;
      ctx.beginPath(); ctx.arc(bx,by,R,0,Math.PI*2);
      ctx.strokeStyle="rgba(180,220,255,.95)"; ctx.lineWidth=3; ctx.stroke();
      ctx.globalAlpha=1;
    }
  });
})();
</script>
<script>
(() => {
  const ZG = window.ZG; if(!ZG) return;

  // ===== Part5: Meta Progression (save/load + upgrades + gacha) =====
  const KEY="ZG_META_SAVE_V1";

  function load(){
    try{
      const raw=localStorage.getItem(KEY);
      if(!raw) return;
      const data=JSON.parse(raw);
      if(data && data.perm){ ZG.meta.perm = Object.assign(ZG.meta.perm, data.perm); }
      if(typeof data.gems==="number") ZG.meta.gems=data.gems;
    }catch{}
  }
  function save(){
    localStorage.setItem(KEY, JSON.stringify({ perm:ZG.meta.perm, gems:ZG.meta.gems }));
  }
  load();

  // convert battle gold -> meta gems at game over / or via button
  function convertGoldToGems(){
    const g = Math.floor(ZG.player.gold / 80);
    if(g<=0) return;
    ZG.player.gold -= g*80;
    ZG.meta.gems += g;
    save();
  }

  function metaPanel(){
    const p=ZG.meta.perm;
    const cards=[
      { t:`Ê∞∏‰πÖÊîªÂáª +1ÔºàÂΩìÂâç ${p.atk}Ôºâ`, d:"ÊèêÈ´òÂ≠êÂºπ/ÁÇÆÂ°î‰º§ÂÆ≥ÔºàÂÖ®Â±ÄÔºâ", cost: (p.atk+1)*3,
        on:()=>{ if(ZG.meta.gems < (p.atk+1)*3) return; ZG.meta.gems -= (p.atk+1)*3; p.atk++; save(); } },
      { t:`Ê∞∏‰πÖÂ∞ÑÈÄü +1ÔºàÂΩìÂâç ${p.fir}Ôºâ`, d:"ÊèêÈ´òÂ∞ÑÈÄüÁ≥ªÊï∞ÔºàÂÖ®Â±ÄÔºâ", cost: (p.fir+1)*3,
        on:()=>{ if(ZG.meta.gems < (p.fir+1)*3) return; ZG.meta.gems -= (p.fir+1)*3; p.fir++; save(); } },
      { t:`Ê∞∏‰πÖÁîüÂëΩ +1ÔºàÂΩìÂâç ${p.hp}Ôºâ`, d:"ÊèêÈ´òÁîüÂëΩ/Êä§ÁõæÔºàÂÖ®Â±ÄÔºâ", cost: (p.hp+1)*3,
        on:()=>{ if(ZG.meta.gems < (p.hp+1)*3) return; ZG.meta.gems -= (p.hp+1)*3; p.hp++; save(); } },
      { t:`Ê∞∏‰πÖÈáëÂ∏Å +1ÔºàÂΩìÂâç ${p.gold}Ôºâ`, d:"ÊèêÈ´òÈáëÂ∏ÅÊéâËêΩÔºàÂÖ®Â±ÄÔºâ", cost: (p.gold+1)*3,
        on:()=>{ if(ZG.meta.gems < (p.gold+1)*3) return; ZG.meta.gems -= (p.gold+1)*3; p.gold++; save(); } },
      { t:`ÊäΩÁÆ±Â≠êÔºà2üíéÔºâ`, d:"ÈöèÊú∫Ëé∑Âæó‰∏ÄÂº†‚ÄúËäØÁâáÂç°‚ÄùÔºà‰∏¥Êó∂Êú¨Â±ÄÂä†ÊàêÔºâ", cost:2,
        on:()=>{ if(ZG.meta.gems<2) return; ZG.meta.gems-=2; const chip = rollChip(); applyChip(chip); save(); } },
      { t:`ÂÖëÊç¢ÈáëÂ∏Å‚ÜíüíéÔºà80üí∞=1üíéÔºâ`, d:"ÊääÂ±ÄÂÜÖÈáëÂ∏ÅÊç¢ÊàêÂ±ÄÂ§ñË¥ßÂ∏Å", on:()=>{ convertGoldToGems(); } },
      { t:`Ê∏ÖÁ©∫Â≠òÊ°£`, d:"ÊµãËØïÁî®ÔºöÈáçÁΩÆÂ±ÄÂ§ñÂÖªÊàê", on:()=>{ localStorage.removeItem(KEY); location.reload(); } },
    ];

    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent = `Â±ÄÂ§ñÂÖªÊàêÔºàüíé=${ZG.meta.gems}Ôºâ`;
    ZG.ui.modalNote.textContent = "ËøôÂ∞±ÊòØÊàêÂìÅÁöÑ‚ÄúÂ±ÄÂ§ñÊàêÈïø‚ÄùÈ™®Êû∂ÔºöÊ∞∏‰πÖÁÇπÊï∞ + ÊäΩÁÆ±Â≠ê„ÄÇ‰∏ã‰∏ÄÊÆµÂÅöÊàêÂìÅÂåñÔºàËèúÂçï/Âπ≥Ë°°/Êó†ÈöúÁ¢ç/Èü≥ÊïàÔºâ„ÄÇ";
    ZG.ui.cards.innerHTML="";
    cards.forEach(c=>{
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML = `<div class="t">${c.t} ${c.cost?`Ôºà${c.cost}üíéÔºâ`:``}</div><div class="d">${c.d||""}</div>`;
      div.onclick = () => { c.on && c.on(); metaPanel(); };
      ZG.ui.cards.appendChild(div);
    });
  }

  // chips (temporary run buffs)
  const CHIPS=[
    { t:"ËäØÁâáÔºöÁàÜ‰º§Âº∫Âåñ", d:"Êö¥ÂáªÂÄçÁéá+0.25ÔºàÊú¨Â±ÄÔºâ", on:()=>{ ZG.build.critMul += 0.25; } },
    { t:"ËäØÁâáÔºöÂºπÂπïÂ¢ûÂπÖ", d:"Ê∫ÖÂ∞Ñ+30ÔºàÊú¨Â±ÄÔºâ", on:()=>{ ZG.build.splash += 30; } },
    { t:"ËäØÁâáÔºöËøûÈîÅÂ¢ûÂπÖ", d:"ËøûÈîÅÈó™Áîµ+1ÔºàÊú¨Â±ÄÔºâ", on:()=>{ ZG.build.chain += 1; } },
    { t:"ËäØÁâáÔºöÊàòÊúØË£ÖÂ°´", d:"Â∞ÑÈÄü+10%ÔºàÊú¨Â±ÄÔºâ", on:()=>{ ZG.build.fireMul *= 1.10; } },
    { t:"ËäØÁâáÔºöËÄê‰πÖÊ®°Âùó", d:"ÊúÄÂ§ßÁîüÂëΩ+25ÔºàÊú¨Â±ÄÔºâ", on:()=>{ ZG.player.hpMax += 25; ZG.player.hp += 25; } },
  ];
  function rollChip(){ return CHIPS[Math.floor(Math.random()*CHIPS.length)]; }
  function applyChip(ch){
    ch.on();
    ZG.ent.floaters.push({ x:ZG.player.x, y:ZG.player.y-60, vy:-40, life:1.2, a:1, text:ch.t });
  }

  // Apply permanent buffs into battle (once)
  function applyPerm(){
    const p=ZG.meta.perm;
    ZG.build.dmgMul *= (1 + p.atk*0.06);
    ZG.build.fireMul*= (1 + p.fir*0.05);
    ZG.player.hpMax += p.hp*18;
    ZG.player.hp = ZG.player.hpMax;
    ZG.player.shMax += p.hp*10;
    ZG.player.sh = Math.min(ZG.player.shMax, ZG.player.sh + p.hp*8);
  }
  // call once after Part3 is loaded
  setTimeout(()=>{ if(ZG.build) applyPerm(); }, 0);

  // Hook meta button
  ZG.ui.btnMeta.onclick = metaPanel;

  // Periodic save gems (if any conversion happens)
  ZG.modules.push(()=>{ /* reserved */ });
})();
</script>
<script>
(() => {
  const ZG = window.ZG; if(!ZG) return;

  // ===== Part6: Product polish (menu + a11y + tiny SFX + balancing) =====
  const audio = (() => {
    try{
      const ac = new (window.AudioContext||window.webkitAudioContext)();
      const beep=(freq=440, dur=0.06, vol=0.04)=>{
        const o=ac.createOscillator(), g=ac.createGain();
        o.type="sine"; o.frequency.value=freq;
        g.gain.value=vol;
        o.connect(g); g.connect(ac.destination);
        o.start(); o.stop(ac.currentTime+dur);
      };
      return { ac, beep };
    }catch{ return { beep:()=>{} }; }
  })();

  // a11y toggles
  ZG.settings = { bigText:false, highContrast:false, sfx:true };

  function openMenu(){
    const cards=[
      { t:"ÂºÄÂßãÊ∏∏Êàè", d:"ËøõÂÖ•ÊàòÊñóÔºàÂâ≤Ëçâ+Â°îÈò≤Ôºâ", on:()=>ZG.ui.overlay.classList.remove("show") },
      { t:"Â±ÄÂ§ñÂÖªÊàê", d:"Ê∞∏‰πÖÂº∫Âåñ/ÊäΩÁÆ±Â≠ê/Â≠òÊ°£", on:()=>ZG.ui.btnMeta.onclick() },
      { t:`Êó†ÈöúÁ¢çÔºöÂ§ßÂ≠ó ${ZG.settings.bigText?"ÂºÄ":"ÂÖ≥"}`, d:"Êõ¥ÈÄÇÂêàËÄÅ‰∫∫Êìç‰Ωú", on:()=>{ZG.settings.bigText=!ZG.settings.bigText; document.body.style.fontSize=ZG.settings.bigText?"18px":"14px"; openMenu();} },
      { t:`È´òÂØπÊØîÔºö${ZG.settings.highContrast?"ÂºÄ":"ÂÖ≥"}`, d:"Êõ¥Ê∏ÖÊô∞", on:()=>{ZG.settings.highContrast=!ZG.settings.highContrast; openMenu();} },
      { t:`Èü≥ÊïàÔºö${ZG.settings.sfx?"ÂºÄ":"ÂÖ≥"}`, d:"ÁÆÄÊòìSFXÔºà‰∏çÂêµÔºâ", on:()=>{ZG.settings.sfx=!ZG.settings.sfx; openMenu();} },
    ];
    ZG.ui.overlay.classList.add("show");
    ZG.ui.modalTitle.textContent="ZÁÇÆ ÊàêÂìÅËØïÁé©ÔºàÂ∑≤Êï¥ÂêàÔºöÂâ≤Ëçâ+Â°îÈò≤+ÂÖªÊàêÔºâ";
    ZG.ui.modalNote.textContent="ÊèêÁ§∫ÔºöÂïÜÂ∫óÊåâÈíÆÔºöÊôÆÈÄöÁÇπ=Ââ≤ËçâÂïÜÂ∫óÔºõÊåâ‰ΩèShiftÁÇπÂïÜÂ∫ó=Â°îÈò≤Âª∫ÈÄ†„ÄÇ";
    ZG.ui.cards.innerHTML="";
    cards.forEach(c=>{
      const div=document.createElement("div");
      div.className="card";
      div.innerHTML=`<div class="t">${c.t}</div><div class="d">${c.d||""}</div>`;
      div.onclick=()=>{ if(ZG.settings.sfx) audio.beep(520,0.05,0.035); c.on(); };
      ZG.ui.cards.appendChild(div);
    });
  }
  openMenu();

  // polish: high contrast affects some draws
  ZG.hook.draw.push(()=>{
    if(!ZG.settings.highContrast) return;
    // simple vignette + brighter outline effect
    const ctx=ZG.ctx;
    ctx.globalAlpha=0.06;
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,8,ZG.h); ctx.fillRect(ZG.w-8,0,8,ZG.h);
    ctx.fillRect(0,0,ZG.w,8); ctx.fillRect(0,ZG.h-8,ZG.w,8);
    ctx.globalAlpha=1;
  });

  // SFX events (cheap)
  const oldSkill = ZG.ui.btnSkill.onclick;
  if(oldSkill){
    ZG.ui.btnSkill.onclick = ()=>{ if(ZG.settings.sfx) audio.beep(240,0.08,0.05); oldSkill(); };
  }
  const oldShop = ZG.ui.btnShop.onclick;
  if(oldShop){
    ZG.ui.btnShop.onclick = ()=>{ if(ZG.settings.sfx) audio.beep(640,0.05,0.03); oldShop(); };
  }

  // balancing: small regen & gold scaling
  ZG.modules.push((dt)=>{
    if(ZG.paused) return;
    // gentle passive heal per wave (elder friendly)
    if(ZG.combat && ZG.combat.state==="between"){
      ZG.player.hp = ZG.clamp(ZG.player.hp + 0.015*dt, 0, ZG.player.hpMax);
    }
  });
})();
</script>

</html>
